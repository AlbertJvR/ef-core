using EFCore.Api.Data.ValueGenerators;
using EFCore.Api.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace EFCore.Api.Data.EntityMapping;

public class GenreMapping : IEntityTypeConfiguration<Genre>
{
    public void Configure(EntityTypeBuilder<Genre> builder)
    {
        builder
            .ToTable("Genres")
            .HasKey(genre => genre.Id);

        builder.Property(genre => genre.Name)
            .HasColumnType("varchar")
            .HasMaxLength(255)
            .IsRequired();

        /*
         * With this approach, we rely on the db engine to generate the value. In this instance, the value generated is
         * outputted by the insert command so EF will have this value. In cases where the value is generated by a trigger
         * or something that EF is not aware of, add the ValueGeneratedOnAdd or ValueGeneratedOnUpdate etc to let EF
         * know to fetch the data and make available once the operation is completed.
         */
        // builder.Property(genre => genre.CreatedDate)
        //     .HasDefaultValueSql("getdate()");

        /*
         * The generator will run when the value is not explicitly set. Additionally, when running seed data this value
         * will not be set as the entries are added as part of the migration process. This will only work when an item is
         * added through the context.
         */
        // builder.Property(genre => genre.CreatedDate)
        //     .HasValueGenerator<CreatedDateGenerator>();

        /*
         * Shadow Properties - properties that are hidden from the developers but still added to the database, such as the
         *      CreatedDate. The value generators and other configurations will work just the same as when the property
         *      is defined in the model.
         * These properties can still be accessed if need be from the app code, e.g.:
         *      _context.Entity(genre).Property("CreatedDate").CurrentValue;
         */
        builder.Property<DateTime>("CreatedDate")
            .HasColumnName("CreatedAt")
            .HasValueGenerator<CreatedDateGenerator>();

        // Seed - data that needs to be created always
        builder.HasData(new List<Genre>
        {
            new Genre
            {
                Id = 1,
                Name = "Fantasy"
            },
            new Genre
            {
                Id = 2,
                Name = "Action"
            },
            new Genre
            {
                Id = 3,
                Name = "Drama"
            }
        });
    }
}